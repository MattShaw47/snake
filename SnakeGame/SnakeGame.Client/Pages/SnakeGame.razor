@using CS3500.Networking;
@using Microsoft.Extensions.Logging;
@using CS3500.Client.Model;
@using System.Net.Sockets;
@using Blazor.Extensions
@using Blazor.Extensions.Canvas;
@using Blazor.Extensions.Canvas.Canvas2D;

@page "/snake"
@rendermode InteractiveServer

<PageTitle>Snake Game</PageTitle>

<h1>Snake Game</h1>

@if (!isConnected)
{
    <button class= "btn btn-primary" @onclick = "Connect" > Connect </button >
}

< div id = "myCanvas" >
    < BECanvas Width = "500" Height = "500" @ref = "canvasReference" />
</ div >

@code
{
    [Inject]
    private ILogger<SnakeGame> Logger { get; set; } = null!;

    // World and canvas variables
    private World world = new();
    private BECanvasComponent canvasReference = null!;
    private Canvas2DContext? context;

    // Lock for thread-safe access to the world
    private readonly object worldLock = new();

    private bool isConnected = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            context = await canvasReference.CreateCanvas2DAsync();
        }
    }

    private async Task Connect()
    {
        try
        {
            TcpClient tcpClient = new TcpClient();
            await tcpClient.ConnectAsync("127.0.0.1", 11000);

            ILogger<ServerHandler> serverHandlerLogger = loggerFactory.CreateLogger<ServerHandler>();
            ILogger networkLogger = loggerFactory.CreateLogger("NetworkLogger");

            NetworkConnection connection = new NetworkConnection(tcpClient, networkLogger);

            serverHandler = new ServerHandler(connection, world, serverHandlerLogger);

            // Start receiving updates from the server
            serverHandler.StartReceiving();

            Logger.LogInformation("Connected to server.")
                isConnected = true;
        }
        catch (Exception ex)
        {
            Logger.LogError($"Failed to connect: {ex.Message}")
                 isConnected = false;
        }
    }

    /// <summary>
    ///   Draw the world
    /// </summary>
    /// <param name="timeStamp">
    ///   Tells you how many milliseconds have
    ///   elapsed sense the web page was loaded.
    /// </param>
    [JSInvokable]
    public async void Draw(double timeStamp = 0)
    {
        frameNumberGUI++;

        double fps = frameNumberGUI / (double)(DateTime.Now - StartTime).TotalSeconds;
        double nps = frameNumberNetwork / (double)(DateTime.Now - ConnectTime).TotalSeconds;
        int timeInSeconds = (int)(timeStamp / 1000);

        try
        {
            // Group all the draw commands into one large single draw.
            await context.BeginBatchAsync();

            // Draw Background.
            await context.SetFillStyleAsync("darkblue");
            await context.FillRectAsync(0, 0, GUIWidth, GUIHeight);

            // Draw walls
            List<Wall> wallsCopy;
            lock (worldLock)
            {
                wallsCopy = world.Walls.ToList();
            }

            foreach (var wall in wallsCopy)
            {
                // Example: Draw wall (logic depends on wall representation)
                await context.SetFillStyleAsync("#f00");
                await context.FillRectAsync(wall.p1.X, wall.p1.Y, 50, 50);
            }

            // Other drawing logic...

            await context.EndBatchAsync();

            // Draw Heads Up Display - do this last so it is on top
            await context.SetFontAsync("30px Arial");
            await context.SetFillStyleAsync("white");
            await context.FillTextAsync($"G-Frame: {frameNumberGUI}", 10, 30);
            await context.FillTextAsync($"N-Frame: {frameNumberNetwork}", 10, 60);
            await context.FillTextAsync($"FPS: {fps:F1}", 400, 30);
            await context.FillTextAsync($"NPS: {nps:F1}", 400, 60);
            await context.FillTextAsync($"Elapsed: {timeInSeconds:F0} seconds", 550, 30);
            await context.FillTextAsync($"Network: {networkStatus}", 10, 90);
            await context.FillTextAsync($"{errorMessage}", 10, 120);

            await context.EndBatchAsync();
        }
        catch (Exception e)
        {
            Logger.LogDetailsBrief(LogLevel.Debug, $"Error drawing: {e}");
        }
    }

    /// <summary>
    /// Changes keypress to a direction and forwards the direction to SendMessage in the
    /// ServerHandler.
    /// </summary>
    /// <param name="key">The key press that the user input.</param>
    /// <exception cref="ArgumentException">Throws an argumentException if given an invalid key.</exception>
    [JSInvokable]
    public void SendMessage(string key)
    {
        string direction;
        if (key == "w" || key == "arrowup")
        {
            direction = "up";
        }
        else if (key == "a" || key == "arrowleft")
        {
            direction = "left";
        }
        else if (key == "s" || key == "arrowdown")
        {
            direction = "down";
        }
        else if (key == "d" || key == "arrowright")
        {
            direction = "right";
        }
        else
        {
            throw new ArgumentException("Invalid movement key.")
            }

        serverHandler?.SendMessage($"{{\"moving\":\"{direction}\"}}");
    }
}
