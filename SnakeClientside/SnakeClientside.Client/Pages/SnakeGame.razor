@page "/snake"
@*
    The following line forces the code to run on the webserver.

    Notice that we run this code on the web server so that
    it has access to the network. If you run this as web assembly
    (i.e., on the browser) it would not be able to connect to
    the snake server using our networking code.
*@
@rendermode InteractiveServer
@implements IDisposable

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Drawing
@using System.Diagnostics
@using CS3500.Networking
@using Microsoft.Extensions.Logging.Abstractions
@using System.Net.Sockets
@using System.Text.Json
@using CS3500.Client.Model;

@inject IJSRuntime JsRuntime;

<PageTitle>Snake Game</PageTitle>

<h1>Snake Game</h1>

@if (!isConnected)
{
    <div>
        <label>Player Name:</label>
        <input @bind="playerName" placeholder="Enter your name" class="form-control" />
        <label>Host:</label>
        <input @bind="host" placeholder="Enter server host" class="form-control" />
        <label>Port:</label>
        <input @bind="port" type="number" placeholder="Enter server port" class="form-control" />
        <button class="btn btn-primary mt-2" @onclick="Connect">Connect</button>
    </div>
}

<div id="myCanvas" tabindex="0" @onkeydown="SendMessage" @ref="movementRef">
    <BECanvas Width="1000" Height="1000" @ref="canvasReference" />
</div>


@code
{
    [Inject]
    private ILogger<SnakeGame> Logger { get; set; } = null!;

    // Movement direct ref
    private ElementReference movementRef;

    // Client info
    private string playerName = string.Empty;
    private Snake? lastKnownPlayerSnake;

    // Pre-connection variables.
    private string host = "127.0.0.1"; // Default to localhost
    private int port = 11000;         // Default port
    private bool isConnected = false;

    // Drawing/Canvas variables here.
    private BECanvasComponent canvasReference = null!;
    private Canvas2DContext context = null!;

    // GUI Model here:
    private int GUIWidth = 1000, GUIHeight = 1000;
    private DateTime StartTime = DateTime.Now;
    private int frameNumberGUI = 0;
    private string errorMessage = string.Empty;
    private Dictionary<int, (string name, int score)> ScoreGUI = new();

    // Controller Model here:
    private IJSObjectReference _jsModule = null!;

    // Network model

    private World? world;
    private ServerHandler? serverHandler;

    /// <summary>
    ///   The first time we start up, we load our JavaScript and start the animation
    ///   process.
    /// </summary>
    /// <param name="firstRender"></param>
    /// <returns></returns>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            world = new World(NullLogger.Instance);

            _jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/SnakeGame.razor.js");
            context = await canvasReference.CreateCanvas2DAsync();

            await _jsModule.InvokeVoidAsync("initJS", DotNetObjectReference.Create(this));
            await _jsModule.InvokeVoidAsync("ToggleAnimation", true);
        }
    }

    /// <summary>
    ///   Attempt to connect to the server and begin the drawing process.
    /// </summary>
    private async void Connect()
    {
        if (string.IsNullOrWhiteSpace(playerName))
        {
            Logger.LogWarning("Player name is required before connecting.");
            return;
        }

        try
        {
            TcpClient tcpClient = new TcpClient();
            await tcpClient.ConnectAsync(host, port);
            using var loggerFactory = LoggerFactory.Create(builder =>
            {
                builder.AddConsole();
                builder.AddDebug();
                builder.SetMinimumLevel(LogLevel.Information);
            });
            ILogger<ServerHandler> serverHandlerLogger = loggerFactory.CreateLogger<ServerHandler>();

            NetworkConnection connection = new NetworkConnection(tcpClient, NullLogger.Instance);
            // World world = new World(worldLogger);

            serverHandler = new ServerHandler(connection, world!, serverHandlerLogger);

            // Start receiving updates from the server
            serverHandler.SendPlayerName(playerName);
            serverHandler.StartReceiving();

            Logger.LogInformation($"Connected to {host}:{port} as {playerName}");
            isConnected = true;
            StateHasChanged();
            await movementRef.FocusAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError($"Failed to connect: {ex.Message}");
            isConnected = false;
        }

    }

    /// <summary>
    ///   Draw the world
    /// </summary>
    /// <param name="timeStamp">
    ///   Tells you how many milliseconds have
    ///   elapsed sense the web page was loaded.
    /// </param>
    [JSInvokable]
    public async void Draw(double timeStamp = 0)
    {
        // Ensure the serverHandler is connected before proceeding
        if (!isConnected)
        {
            return;
        }

        frameNumberGUI++;
        double fps = frameNumberGUI / (DateTime.Now - StartTime).TotalSeconds;

        try
        {

            // Determine the player's position for centering
            var (offsetX, offsetY) = GetPlayerOffsets();

            // Group all the draw commands into one large single draw.
            await context.BeginBatchAsync();

            // Draw components
            await DrawBackground();
            await DrawWalls(offsetX, offsetY);
            await DrawPowerups(offsetX, offsetY);
            await DrawSnakes(offsetX, offsetY);
            await DrawHUD(fps);

            await context.EndBatchAsync();
        }
        catch (Exception e)
        {
            Logger.LogError($"Failed drawing: {e}");
        }
    }

    /// <summary>
    ///   <para>
    ///     This method is called from the JavaScript side of the
    ///     browser.
    ///   </para>
    ///   <remarks>
    ///      Must be PUBLIC for JavaScript to call!
    ///   </remarks>
    /// </summary>
    /// <param name="width"></param>
    /// <param name="height"></param>
    [JSInvokable]
    public void ResizeInBlazor(int width, int height)
    {
        Logger.LogTrace("Resizing the web page. {width} {height}", width, height);
        GUIWidth = Math.Min(Math.Max(100, width), 1000);
        GUIHeight = Math.Min(Math.Max(100, height), 1000);
    }

    /// <summary>
    ///   Called by the system when the page is navigated away from.
    ///   Note: sometimes the debugger will create a "dummy" page when
    ///   first navigated to, then dispose it, then create the actual page.
    ///   You can ignore this behavior.
    /// </summary>
    public void Dispose()
    {
        _jsModule.InvokeVoidAsync("ToggleAnimation", false);
    }

    private (int offsetX, int offsetY) GetPlayerOffsets()
    {
        Snake? playerSnake = null;

        lock (world!.Snakes)
        {
            // Try to fetch the player snake
            if (world.Snakes.TryGetValue(serverHandler!.PlayerId, out var foundSnake))
            {
                playerSnake = foundSnake;
            }
        }

        // Fallback to last-known value
        if (playerSnake is null && lastKnownPlayerSnake is not null)
        {
            playerSnake = lastKnownPlayerSnake;
        }

        if (playerSnake is null || playerSnake.Body.Count == 0)
        {
            return (0, 0); // No valid offsets
        }

        lastKnownPlayerSnake = playerSnake;

        // Get the player's head position and calculate offsets
        var playerHead = playerSnake.Body.Last();
        int offsetX = (int)(playerHead.X - GUIWidth / 2);
        int offsetY = (int)(playerHead.Y - GUIHeight / 2);

        return (offsetX, offsetY);
    }


    private async Task DrawBackground()
    {
        await context.SetFillStyleAsync("rgb(0,128,0)");
        await context.FillRectAsync(0, 0, GUIWidth, GUIHeight);
    }

    private async Task DrawWalls(int offsetX, int offsetY)
    {
        List<Wall> wallCopy;
        lock (world!.Walls)
        {
            wallCopy = world.Walls.Values.ToList();
        }

        foreach (Wall wall in wallCopy)
        {
            // Adjust wall points for canvas offset
            int x1 = wall.P1.X - offsetX;
            int y1 = wall.P1.Y - offsetY;
            int x2 = wall.P2.X - offsetX;
            int y2 = wall.P2.Y - offsetY;

            // Extend the wall slightly beyond endpoints
            var dx = x2 - x1;
            var dy = y2 - y1;
            var magnitude = Math.Sqrt(dx * dx + dy * dy);

            // Calculate extensions (normalized direction vector scaled by 50)
            double extendX = (dx / magnitude) * 25;
            double extendY = (dy / magnitude) * 25;

            int extendedX1 = (int)(x1 - extendX);
            int extendedY1 = (int)(y1 - extendY);
            int extendedX2 = (int)(x2 + extendX);
            int extendedY2 = (int)(y2 + extendY);

            // Draw the wall as a thick line
            await context.BeginPathAsync();
            await context.MoveToAsync(extendedX1, extendedY1);
            await context.LineToAsync(extendedX2, extendedY2);
            await context.SetLineWidthAsync(50); // Thickness of the wall
            await context.SetStrokeStyleAsync("gray"); // Wall color
            await context.StrokeAsync();
        }
    }

    private async Task DrawPowerups(int offsetX, int offsetY)
    {
        List<Powerup> powerupCopy;
        lock (world!.Powerups)
        {
            powerupCopy = world.Powerups.Values.ToList();
        }

        // Smootly moves between 0 and 1
        double pulseFactor = (Math.Sin(DateTime.Now.Ticks / 10000000.0) + 1) * 0.5;

        foreach (Powerup powerup in powerupCopy)
        {
            if (!powerup.IsDead)
            {
                int size = 16;

                double radius = size + pulseFactor * 5; // Pulsating radius
                int x = powerup.P.X - offsetX - size / 2;
                int y = powerup.P.Y - offsetY - size / 2;

                if (IsInViewport(x, y, size, size))
                {
                    await context.BeginPathAsync();
                    await context.SetFillStyleAsync("gold");
                    await context.ArcAsync(x + size / 2, y + size / 2, size / 2, 0, 2 * Math.PI);
                    await context.FillAsync();

                    await context.BeginPathAsync();
                    await context.SetStrokeStyleAsync("orange");
                    await context.SetLineWidthAsync(2);
                    await context.ArcAsync(x + size / 2, y + size / 2, (radius / 2) + 2, 0, 2 * Math.PI);
                    await context.StrokeAsync();
                }
            }
        }
    }

    private async Task DrawSnakes(int offsetX, int offsetY)
    {
        List<Snake> snakeCopy = new();
        lock (world!.Snakes)
        {
            snakeCopy = world.Snakes.Values.ToList();
        }

        foreach (Snake snake in snakeCopy)
        {
            if (snake.Died)
            {
                ScoreGUI.Remove(snake.Id);
                continue;
            }

            ScoreGUI[snake.Id] = (snake.Name, snake.Score);

            string snakeColor = GetSnakeColor(snake);

            // Start from the tail and move towards the head
            for (int i = snake.Body.Count - 1; i > 0; i--)
            {
                var current = snake.Body[i];
                var next = snake.Body[i - 1];

                float segmentWidth = 10;

                await context.BeginPathAsync();
                await context.MoveToAsync(current.X - offsetX, current.Y - offsetY);
                await context.LineToAsync(next.X - offsetX, next.Y - offsetY);
                await context.SetStrokeStyleAsync(snakeColor);
                await context.SetLineWidthAsync(segmentWidth);
                await context.StrokeAsync();
            }

            // Draws snake head
            var head = snake.Body.Last();
            await context.BeginPathAsync();
            await context.SetFillStyleAsync(snakeColor);
            await context.ArcAsync(head.X - offsetX, head.Y - offsetY, 9, 0, 2 * Math.PI); // Head radius
            await context.FillAsync();

            // Draws eyes
            double eyeOffset = 3;
            double eyeRadius = 2;
            await context.SetFillStyleAsync("white");
            await context.BeginPathAsync();
            await context.ArcAsync(head.X - offsetX - eyeOffset, head.Y - offsetY - eyeOffset, eyeRadius, 0, 2 * Math.PI); // Left eye
            await context.ArcAsync(head.X - offsetX + eyeOffset, head.Y - offsetY - eyeOffset, eyeRadius, 0, 2 * Math.PI); // Right eye
            await context.FillAsync();
        }
    }


    private async Task DrawHUD(double fps)
    {
        await context.SetFontAsync("20px Arial");
        await context.FillTextAsync($"FPS: {fps:F1}", 400, 30);

        List<KeyValuePair<int, (string name, int score)>> scoreList = new List<KeyValuePair<int, (string name, int score)>>(ScoreGUI);
        scoreList.Sort((x, y) => y.Value.score.CompareTo(x.Value.score));
        var topScores = scoreList.Take(5);

        int yPosition = 160;
        foreach (var score in topScores)
        {
            await context.SetFillStyleAsync("white");

            if(score.Key == serverHandler!.PlayerId)
            {
                await context.SetFillStyleAsync("gold");
            }

            string snakeName = score.Value.name;
            if (snakeName.StartsWith("{\"name\":\"") && snakeName.EndsWith("\"}"))
            {
                snakeName = snakeName.Substring(9, snakeName.Length - 11);
            }

            await context.FillTextAsync($"{snakeName}: {score.Value.score}", 10, yPosition);

            yPosition += 40;
        }
    }

    private bool IsInViewport(int x, int y, int width, int height)
    {
        return x + width >= 0 && x <= GUIWidth && y + height >= 0 && y <= GUIHeight;
    }

    private string GetSnakeColor(Snake snake)
    {
        if (snake.Died is true || snake.Alive is false)
        {
            return "black";
        }
        else if (snake.Id == serverHandler!.PlayerId)
        {
            return "red";
        }

        int hash = Math.Abs(snake.Name.GetHashCode());
        int r = (hash % 256);
        int g = ((hash / 256) % 256);
        int b = ((hash / (256 * 256)) % 256);

        // Avoids pure black snake
        if (r < 50 && g < 50 && b < 50)
        {
            r += 100;
            g += 100;
            b += 100;
        }

        // Avoids green snake (cuz the background is green.)
        if (g > r && g > b && g > 128)
        {
            g -= 128;
        }

        return $"rgb({r},{g},{b})";
    }

    /// <summary>
    /// Changes keypress to a direction and forwards the direction to SendMessage in the
    /// ServerHandler.
    /// </summary>
    /// <param name="key">The key press that the user input.</param>
    /// <exception cref="ArgumentException">Throws an argumentException if given an invalid key.</exception>
    private void SendMessage(KeyboardEventArgs e)
    {
        serverHandler?.SendMessage(e.Key.ToString().ToLower());
    }
}
